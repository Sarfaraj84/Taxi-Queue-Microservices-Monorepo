const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');
const path = require('path');

class {{serviceNamePascal}}Client {
  constructor(serviceUrl = process.env.{{serviceNameUpperCase}}_SERVICE_URL || 'localhost:{{port}}') {
    const PROTO_PATH = path.join(__dirname, '../proto/{{serviceName}}.proto');
    const packageDefinition = protoLoader.loadSync(PROTO_PATH, {
      keepCase: true,
      longs: String,
      enums: String,
      defaults: true,
      oneofs: true
    });

    const {{serviceName}}Proto = grpc.loadPackageDefinition(packageDefinition).{{serviceName}};
    this.client = new {{serviceName}}Proto.{{serviceNamePascal}}Service(
      serviceUrl,
      grpc.credentials.createInsecure()
    );
  }

  // Health check
  healthCheck() {
    return new Promise((resolve, reject) => {
      this.client.healthCheck({}, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  {{#if (eq serviceName 'auth')}}
  // Auth service methods
  login(email, password) {
    return new Promise((resolve, reject) => {
      this.client.login({ email, password }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  register(userData) {
    return new Promise((resolve, reject) => {
      this.client.register(userData, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  verifyToken(token) {
    return new Promise((resolve, reject) => {
      this.client.verifyToken({ token }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  refreshToken(token) {
    return new Promise((resolve, reject) => {
      this.client.refreshToken({ token }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }
  {{/if}}

  {{#if (eq serviceName 'user')}}
  // User service methods
  getUser(userId) {
    return new Promise((resolve, reject) => {
      this.client.getUser({ userId }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getUsers(options = {}) {
    return new Promise((resolve, reject) => {
      this.client.getUsers(options, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  updateUser(userId, updates) {
    return new Promise((resolve, reject) => {
      this.client.updateUser({ userId, ...updates }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  deleteUser(userId) {
    return new Promise((resolve, reject) => {
      this.client.deleteUser({ userId }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  createUser(userData) {
    return new Promise((resolve, reject) => {
      this.client.createUser(userData, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }
  {{/if}}

  {{#if (eq serviceName 'queue')}}
  // Queue service methods
  addToQueue(driverId, vehicleType, queueType = 'primary') {
    return new Promise((resolve, reject) => {
      this.client.addToQueue({ driverId, vehicleType, queueType }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  removeFromQueue(driverId, queueType) {
    return new Promise((resolve, reject) => {
      this.client.removeFromQueue({ driverId, queueType }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getQueueStatus(queueType, vehicleType) {
    return new Promise((resolve, reject) => {
      this.client.getQueueStatus({ queueType, vehicleType }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getDriverPosition(driverId, queueType) {
    return new Promise((resolve, reject) => {
      this.client.getDriverPosition({ driverId, queueType }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  releaseDrivers(queueType, count, terminal, vehicleRequirements = {}) {
    return new Promise((resolve, reject) => {
      this.client.releaseDrivers({ queueType, count, terminal, vehicleRequirements }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  handleAirportClosure(reason = 'end-of-day', priorityExpiryHours = 12) {
    return new Promise((resolve, reject) => {
      this.client.handleAirportClosure({ reason, priorityExpiryHours }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }
  {{/if}}

  {{#if (eq serviceName 'geo')}}
  // Geo service methods
  isPointInGeofence(latitude, longitude, geofenceId) {
    return new Promise((resolve, reject) => {
      this.client.isPointInGeofence({ latitude, longitude, geofenceId }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  addGeofence(id, name, coordinates) {
    return new Promise((resolve, reject) => {
      this.client.addGeofence({ id, name, coordinates }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  calculateDistance(fromLat, fromLng, toLat, toLng) {
    return new Promise((resolve, reject) => {
      this.client.calculateDistance({ fromLat, fromLng, toLat, toLng }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }
  {{/if}}

  {{#if (eq serviceName 'vehicle')}}
  // Vehicle service methods
  registerVehicle(driverId, vehicleData) {
    return new Promise((resolve, reject) => {
      this.client.registerVehicle({ driverId, ...vehicleData }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  setActiveVehicle(driverId, vehicleId) {
    return new Promise((resolve, reject) => {
      this.client.setActiveVehicle({ driverId, vehicleId }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getDriverVehicles(driverId) {
    return new Promise((resolve, reject) => {
      this.client.getDriverVehicles({ driverId }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  updateVehicle(vehicleId, updates) {
    return new Promise((resolve, reject) => {
      this.client.updateVehicle({ vehicleId, ...updates }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  deleteVehicle(vehicleId) {
    return new Promise((resolve, reject) => {
      this.client.deleteVehicle({ vehicleId }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }
  {{/if}}

  {{#if (eq serviceName 'payment')}}
  // Payment service methods
  processPayment(driverId, amount, terminal, description, vehicleType) {
    return new Promise((resolve, reject) => {
      this.client.processPayment({ driverId, amount, terminal, description, vehicleType }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getPayment(paymentId) {
    return new Promise((resolve, reject) => {
      this.client.getPayment({ paymentId }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getDriverPayments(driverId, options = {}) {
    return new Promise((resolve, reject) => {
      this.client.getDriverPayments({ driverId, ...options }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  refundPayment(paymentId, reason) {
    return new Promise((resolve, reject) => {
      this.client.refundPayment({ paymentId, reason }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getDriverBalance(driverId) {
    return new Promise((resolve, reject) => {
      this.client.getDriverBalance({ driverId }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }
  {{/if}}

  {{#if (eq serviceName 'config')}}
  // Config service methods
  getConfig(key) {
    return new Promise((resolve, reject) => {
      this.client.getConfig({ key }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  updateConfig(key, value) {
    return new Promise((resolve, reject) => {
      this.client.updateConfig({ key, value }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getFeeConfig(terminal, vehicleType) {
    return new Promise((resolve, reject) => {
      this.client.getFeeConfig({ terminal, vehicleType }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  updateFeeConfig(configData) {
    return new Promise((resolve, reject) => {
      this.client.updateFeeConfig(configData, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }

  getSystemConfig(section) {
    return new Promise((resolve, reject) => {
      this.client.getSystemConfig({ section }, (error, response) => {
        error ? reject(error) : resolve(response);
      });
    });
  }
  {{/if}}

  // Close connection
  close() {
    if (this.client) {
      this.client.close();
    }
  }

  // Get client state
  getState() {
    return {
      connected: !!this.client,
      serviceUrl: this.client?.getChannel().getTarget()
    };
  }

  // Wait for connection
  waitForReady(timeout = 5000) {
    return new Promise((resolve, reject) => {
      const deadline = Date.now() + timeout;
      this.client.waitForReady(deadline, (error) => {
        error ? reject(error) : resolve();
      });
    });
  }
}

module.exports = {{serviceNamePascal}}Client;